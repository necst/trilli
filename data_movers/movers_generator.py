# MIT License

# Copyright (c) 2025 Giuseppe Sorrentino, Paolo Salvatore Galfano, Davide Conficconi, Eleonora D'Arnese

# Permission is hereby granted, free of charge, to any person obtaining a copy
# of this software and associated documentation files (the "Software"), to deal
# in the Software without restriction, including without limitation the rights
# to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
# copies of the Software, and to permit persons to whom the Software is
# furnished to do so, subject to the following conditions:

# The above copyright notice and this permission notice shall be included in all
# copies or substantial portions of the Software.

# THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
# IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
# FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
# AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
# LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
# OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
# SOFTWARE.


import math
import sys
import numpy as np

def generate_range_defines(BI, step = 32, byte = True, suffix=""):
    lines = []
    for i in range(0, BI):
        lines.append(f"#define RANGE_{suffix}{format(step*(i+1), '03d')}_{format(step*i, '03d')} {(8 if byte else 1)*step*(i+1)-1}, {(8 if byte else 1)*step*i}")
    return lines

# used to generate the setup_interpolator_body.hpp file
def generate_write(PE, BI):
    lines = []
    lines.append("#pragma once")
    lines.append("\n// This file is generated by data_movers/movers_generator.py\n")

    lines.extend(generate_range_defines(BI))

    # ----------------- SETUP_INTERPOLATOR_SIGNATURE -----------------

    lines.append("")
    lines.append("#define SETUP_INTERPOLATOR_SIGNATURE \\")
    for i in range(0, PE):
        comma = "," if i < PE - 1 else ""
        lines.append(f"\thls::stream<ap_uint<INPUT_DATA_BITWIDTH_FETCHER_MIN>>& out_{i+1}{comma} \\")
    lines.append("")

    # ----------------- SETUP_INTERPOLATOR_TESTBENCH_CALL -----------------
    lines.append("#define SETUP_INTERPOLATOR_TESTBENCH_CALL(x) \\")
    for i in range(0, PE):
        comma = "," if i < PE - 1 else ""
        lines.append(f"\tx[{i}]{comma} \\")
    lines.append("")

    # ----------------- SETUP_INTERPOLATOR_PRAGMAS -----------------

    lines.append("#define PRAGMA_SUB(x) _Pragma (#x) // source: https://docs.xilinx.com/r/en-US/ug1399-vitis-hls/Using-Constants-with-Pragmas")
    lines.append("#define PRAGMA_HLS(x) PRAGMA_SUB(x)")
    lines.append("#define SETUP_INTERPOLATOR_PRAGMAS \\")
    for i in range(0, PE):
        lines.append(f"\tPRAGMA_HLS(HLS interface axis depth=524288 port=out_{i+1}) \\")
    lines.append("")

    # ----------------- SETUP_INTERPOLATOR_AIE_STARTER -----------------

    lines.append("#define SETUP_INTERPOLATOR_AIE_STARTER \\")

    for i in range (0, PE):
        lines.append(f"\tdata.range(7,0) = {i}; \\")
        lines.append(f"\tout_{i+1}.write(data); \\")
        lines.append(f"\tout_{i+1}.write(data); \\")
    lines.append("")

    # ----------------- SETUP_INTERPOLATOR_BODY -----------------

    lines.append("#define SETUP_INTERPOLATOR_BODY \\")

    ranges = ["RANGE_" + format(32*(i+1), "03d") + "_" + format(32*i, "03d") for i in range(0, BI)]
    output = ["out_" + str(i+1) for i in range(0, PE)]

    M = max(PE, BI)

    # iterates on chunks of 32
    for i in range(0, M):
        if i % BI == 0:
            lines.append("\tA = Left_in.read(); \\")
            lines.append("\tB = Right_in.read(); \\")
        out = output[i % PE]
        rng = ranges[i % BI]
        lines.append(f"\t{out}.write(A.range({rng})); \\")
        lines.append(f"\t{out}.write(B.range({rng})); \\")
    
    lines.append("\n")
    

    return lines



# used to generate the writer_body.hpp file
def generate_read(PE, BI):
    lines = []
    lines.append("#pragma once")
    lines.append("// This file is generated by data_movers/movers_generator.py")

    lines.extend(generate_range_defines(BI))

    # ----------------- WRITER_SIGNATURE -----------------

    lines.append("")
    lines.append("#define WRITER_SIGNATURE \\")
    for i in range(0, PE):
        comma = "," if i < PE - 1 else ""
        lines.append(f"\thls::stream<ap_uint<INPUT_DATA_BITWIDTH_FETCHER_MIN>>& pixels_in_{i+1}{comma} \\")
    lines.append("")

    # ----------------- WRITER_TESTBENCH_CALL -----------------
    lines.append("#define WRITER_TESTBENCH_CALL(x) \\")
    for i in range(0, PE):
        comma = "," if i < PE - 1 else ""
        lines.append(f"\tx[{i}]{comma} \\")
    lines.append("")

    # ----------------- WRITER_PRAGMAS -----------------

    lines.append("#define PRAGMA_SUB(x) _Pragma (#x) // source: https://docs.xilinx.com/r/en-US/ug1399-vitis-hls/Using-Constants-with-Pragmas")
    lines.append("#define PRAGMA_HLS(x) PRAGMA_SUB(x)")
    lines.append("#define WRITER_PRAGMAS \\")
    for i in range(0, PE):
        lines.append(f"\tPRAGMA_HLS(HLS interface axis depth=524288 port=pixels_in_{i+1}) \\")
    lines.append("")

    # ----------------- WRITER_BODY -----------------

    lines.append("#define WRITER_BODY \\")

    ranges = ["RANGE_" + format(32*(i+1), "03d") + "_" + format(32*i, "03d") for i in range(0, BI)]
    output = ["pixels_in_" + str(i+1) for i in range(0, PE)]

    M = max(PE, BI)
    D = int(math.log2(PE / BI))

    # iterates on chunks of 32
    for i in range(0, M):
        out = output[i % PE]
        rng = ranges[i % BI]
        lines.append(f"\tpixels.range({rng}) = {out}.read(); \\")
        if i % BI == BI - 1:
            lines.append("\tpixels_out[" + (f"(i << {D}) + {math.floor(i / BI)}" if D > 0 else "i") + "] = pixels; \\")
    
    lines.append("\n")
    
    return lines


# used to generate the setup_mi_body.hpp file
def generate_passing(IPE, HPE, suffix="", BI=1):
    lines = []

    if suffix[:-1] == "":
        lines.append("#pragma once")
        lines.append("// This file is generated by data_movers/movers_generator.py")
    else:
        suffix += "_"

    tooManyHPEs = HPE > 32

    K = 32 // HPE if not tooManyHPEs else HPE // 32
    HPE_sat = HPE if not tooManyHPEs else 32

    print(f"K = {K}")

    lines.extend(generate_range_defines(32, HPE_sat, True, suffix)[0:K])
    lines.extend(generate_range_defines(BI, 32, True, "WRITER_")[0:BI//32])

    # ----------------- SETUP_MI_SIGNATURE -----------------

    lines.append("")
    lines.append(f"#define SETUP_MI_{suffix}SIGNATURE \\")
    for i in range(0, IPE):
        comma = "," if i < IPE - 1 else ""
        lines.append(f"\thls::stream<ap_uint<INPUT_DATA_BITWIDTH_FETCHER_MIN>>& pixels_in_{i+1}{comma} \\")
    lines.append("")

    # ----------------- SETUP_MI_TESTBENCH_CALL -----------------
    lines.append(f"#define SETUP_MI_{suffix}TESTBENCH_CALL(x) \\")
    for i in range(0, IPE):
        comma = "," if i < IPE - 1 else ""
        lines.append(f"\tx[{i}]{comma} \\")
    lines.append("")

    # ----------------- SETUP_MI_PRAGMAS -----------------

    if suffix == "":
        lines.append("#define PRAGMA_SUB(x) _Pragma (#x) // source: https://docs.xilinx.com/r/en-US/ug1399-vitis-hls/Using-Constants-with-Pragmas")
        lines.append("#define PRAGMA_HLS(x) PRAGMA_SUB(x)")
        lines.append("#define SETUP_MI_PRAGMAS \\")
        for i in range(0, IPE):
            lines.append(f"\tPRAGMA_HLS(HLS interface axis depth=524288 port=pixels_in_{i+1}) \\")
        lines.append("")

    # ----------------- SETUP_MI_VOLUME -----------------
    Y = (np.lcm(IPE * 32, BI)) // (IPE * 32)
    expo_y = np.log2(Y)
    lines.append(f"#define SETUP_MI_{suffix}VOLUME \\")
    lines.append(f"//The last division is due to the unrolling factor computer at compile time ")
    lines.append(f"int unrolling_factor_expo = { int(expo_y) }; \\")
    lines.append(f"int VOLUME_withoutDepth = ((DIMENSION * DIMENSION >> INT_PE_EXPO) >> 5 )>> unrolling_factor_expo; \\")
    lines.append(f"\n")

    # ----------------- SETUP_MI_(WRITER)_BODY -----------------

    lines.append(f"#define SETUP_MI_{suffix}BODY \\")

    #ranges = ["RANGE_" + format(8*(i+1), "03d") + "_" + format(8*i, "03d") for i in range(0, 32)]
    ranges = [f"RANGE_{suffix}{format(HPE_sat*(i+1), '03d')}_{format(HPE_sat*i, '03d')}" for i in range(0, K)]
    ranges_w = [f"RANGE_WRITER_{format(32*(i+1), '03d')}_{format(32*i, '03d')}" for i in range(0, BI//32)]

    print(ranges)

    M = max(IPE, HPE)
    D = int(math.log2(32 * IPE))
    print(f"BI = {BI}")


    print(f"Y = {Y}")

    assert(BI >= 32)
    PPR = BI // 32 # pixels per read
    print(f"PPR = {PPR}")
    check = 0
    if suffix == "":
        for n in range (0,Y):
            for i in range(0, IPE):
                if not tooManyHPEs:
                    if ((i % PPR == 0) and ((n+1)==Y)):
                        lines.append(f"\tap_uint<INPUT_DATA_BITWIDTH_FETCHER> pixels_mem_{1+i//PPR}; \\")
                    lines.append(f"\tap_uint<INPUT_DATA_BITWIDTH_FETCHER_MIN> pixels_{i+1+n*IPE} = pixels_in_{i+1}.read(); \\")
                    for j in range(0, K):
                        rng = ranges[j]
                        lines.append(f"\tpixels_out.write(pixels_{i+1+n*IPE}.range({rng})); \\")
                    if (i % PPR == PPR - 1):
                        check = 1
                        for k in range(0, PPR):
                            rng = ranges_w[k]
                            lines.append(f"\tpixels_mem_{1+i//PPR}.range({rng}) = pixels_{i+k-(PPR-1)+1+n*IPE}; \\")
                        lines.append(f"\tpixels_out_mem[(i << {int(math.log2(IPE//PPR))}) + {i//PPR}] = pixels_mem_{1+i//PPR}; \\")
                else:
                    raise NotImplementedError("Not implemented for HPE > 32") 
            if(n+1==Y and (not check)):
                for k in range(0, PPR):
                    rng = ranges_w[k]
                    lines.append(f"\tpixels_mem_{1+i//PPR}.range({rng}) = pixels_{i+k-(PPR-1)+1+n*IPE}; \\")
                lines.append(f"\tpixels_out_mem[i] = pixels_mem_{1+i//PPR}; \\")


#                    if i % PPR == 0:
#                        lines.append(f"\tap_uint<INPUT_DATA_BITWIDTH_FETCHER> pixels_mem_{1+i//PPR}; \\")
#                    lines.append(f"\tap_uint<INPUT_DATA_BITWIDTH> pixels_{i+1};")
#                    for j in range(0, K):
#                        lines.append(f"\tpixels_{i+1}.range({ranges[j]}) = pixels_in_{i+1}.read(); \\")
#                    lines.append(f"\tpixels_out.write(pixels_{i+1}); \\")
                
    # elif suffix[:-1] == "WRITER":
    #     assert HPE >= 32
    #     K = 32 // IPE
    #     print(f"K = {K}")
    #     for i in range(0, K):
    #         lines.append(f"\tap_uint<INPUT_DATA_BITWIDTH_FETCHER> pixels_mem_{1+i}; \\")
    #         for j in range(0, IPE // K):
    #             rng = ranges[j]
    #             lines.append(f"\tpixels_mem_{1+i}.range({rng}) = pixels_in_{(IPE // K)*i+j+1}.read(); \\")
    #         lines.append(f"\tpixels_out_mem[{i} << {int(math.log2(K))} + {i}] = pixels_mem_{1+i}; \\")
            
            # lines.append(f"\tpixels_out_mem[{i} << {int(math.log2(IPE))} + {math.floor(i / K)}].range({rng}) = pixels_{i+1}.range({rng}); \\")


        # for i in range(0, HPE // 32):
        #     lines.append(f"\tap_uint<INPUT_DATA_BITWIDTH> pixels_{i+1};")
        #     for j in range(0, K):
        #         lines.append(f"\tpixels_{i+1}.range({ranges[j]}) = pixels_in_{i+1}.read(); \\")
        #     lines.append(f"\tpixels_out_mem[{i} << {int(math.log2(IPE))} + {math.floor(i / K)}] = pixels_{i+1}; \\")

    lines.append("\n")
    
    return lines

if len(sys.argv) < 4:
    print("Usage: python3 movers_generator.py <INT_PE> <BITWIDTH> <HISTO_PE>")
    exit(1)

arg_IPE = int(sys.argv[1])
arg_BI = int(int(sys.argv[2]) / 32)
# arg_BI = int(64 / 32)
arg_HPE = int(sys.argv[3])

setup_interpolator_file = open("setup_interpolator_body.hpp", "w")
setup_interpolator_lines = generate_write(arg_IPE, arg_BI)
setup_interpolator_file.write("\n".join(setup_interpolator_lines))

writer_file = open("writer_body.hpp", "w")
writer_lines = generate_read(arg_IPE, arg_BI)
writer_file.write("\n".join(writer_lines))

setup_mi_file = open("setup_mi_body.hpp", "w")
setup_mi_lines = generate_passing(arg_IPE, arg_HPE, "", 32 * arg_BI)
# setup_mi_lines += generate_passing(arg_IPE, 32 * arg_BI, "WRITER")
setup_mi_file.write("\n".join(setup_mi_lines))
